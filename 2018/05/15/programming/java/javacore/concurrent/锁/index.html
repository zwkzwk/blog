<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
      
    
    
      
    
  <script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script>
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/themes/blue/pace-theme-minimal.min.css">























<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/blog/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Muse',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":true,"dimmer":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="锁  📓 本文已归档到：「blog」 本文内容基于 JDK1.8。    概述  概念 为什么用 Lock、ReadWriteLock   Lock 和 ReentrantLock  要点 源码 示例   ReadWriteLock 和 ReentrantReadWriteLock  要点 源码 示例   AQS  要点 源码   资料    概述  概念  公平锁/非公平锁 公平锁是指多个线">
<meta name="keywords" content="programming,java,javacore,concurrent,lock">
<meta property="og:type" content="article">
<meta property="og:title" content="锁">
<meta property="og:url" content="https://dunwu.github.io/2018/05/15/programming/java/javacore/concurrent/锁/index.html">
<meta property="og:site_name" content="张鹏的博客">
<meta property="og:description" content="锁  📓 本文已归档到：「blog」 本文内容基于 JDK1.8。    概述  概念 为什么用 Lock、ReadWriteLock   Lock 和 ReentrantLock  要点 源码 示例   ReadWriteLock 和 ReentrantReadWriteLock  要点 源码 示例   AQS  要点 源码   资料    概述  概念  公平锁/非公平锁 公平锁是指多个线">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/images/java/concurrent/ReentrantLock-diagram.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/images/java/concurrent/ReadWriteLock.jpg">
<meta property="og:image" content="http://www.liuhaihua.cn/wp-content/uploads/2018/05/7zei6fI.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/images/java/concurrent/aqs-acquireQueued-before.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/images/java/concurrent/aqs-acquireQueued-after.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/images/java/concurrent/aqs-acquire-flow.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/images/java/concurrent/aqs-doAcquireNanos-flow.png">
<meta property="og:updated_time" content="2019-03-07T05:15:43.041Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="锁">
<meta name="twitter:description" content="锁  📓 本文已归档到：「blog」 本文内容基于 JDK1.8。    概述  概念 为什么用 Lock、ReadWriteLock   Lock 和 ReentrantLock  要点 源码 示例   ReadWriteLock 和 ReentrantReadWriteLock  要点 源码 示例   AQS  要点 源码   资料    概述  概念  公平锁/非公平锁 公平锁是指多个线">
<meta name="twitter:image" content="https://raw.githubusercontent.com/dunwu/images/master/images/java/concurrent/ReentrantLock-diagram.png">



  <link rel="alternate" href="/blog/atom.xml" title="张鹏的博客" type="application/atom+xml">




  <link rel="canonical" href="https://dunwu.github.io/2018/05/15/programming/java/javacore/concurrent/锁/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>锁 | 张鹏的博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">张鹏的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">大道至简，知易行难</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/blog/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/blog/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/blog/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/blog/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/blog/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    
  
  
  
  

  

  <a href="https://github.com/dunwu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" style="fill: #222; color: #fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  
    <div class="reading-progress-bar"></div>
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/2018/05/15/programming/java/javacore/concurrent/锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张鹏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">锁<a href="https://github.com/dunwu/blog/blob/master/source/_posts/programming/java/javacore/concurrent/锁.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pencil"></i></a>

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-15 17:52:00" itemprop="dateCreated datePublished" datetime="2018-05-15T17:52:00+08:00">2018-05-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-07 13:15:43" itemprop="dateModified" datetime="2019-03-07T13:15:43+08:00">2019-03-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/programming/" itemprop="url" rel="index"><span itemprop="name">programming</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/programming/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/programming/java/javacore/" itemprop="url" rel="index"><span itemprop="name">javacore</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/programming/java/javacore/concurrent/" itemprop="url" rel="index"><span itemprop="name">concurrent</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">19k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">17 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="锁"><a class="markdownIt-Anchor" href="#锁"></a> 锁</h1>
<blockquote>
<p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p>
<p>本文内容基于 JDK1.8。</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E6%A6%82%E8%BF%B0">概述</a>
<ul>
<li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-lockreadwritelock">为什么用 Lock、ReadWriteLock</a></li>
</ul>
</li>
<li><a href="#lock-%E5%92%8C-reentrantlock">Lock 和 ReentrantLock</a>
<ul>
<li><a href="#%E8%A6%81%E7%82%B9">要点</a></li>
<li><a href="#%E6%BA%90%E7%A0%81">源码</a></li>
<li><a href="#%E7%A4%BA%E4%BE%8B">示例</a></li>
</ul>
</li>
<li><a href="#readwritelock-%E5%92%8C-reentrantreadwritelock">ReadWriteLock 和 ReentrantReadWriteLock</a>
<ul>
<li><a href="#%E8%A6%81%E7%82%B9-1">要点</a></li>
<li><a href="#%E6%BA%90%E7%A0%81-1">源码</a></li>
<li><a href="#%E7%A4%BA%E4%BE%8B-1">示例</a></li>
</ul>
</li>
<li><a href="#aqs">AQS</a>
<ul>
<li><a href="#%E8%A6%81%E7%82%B9-2">要点</a></li>
<li><a href="#%E6%BA%90%E7%A0%81-2">源码</a></li>
</ul>
</li>
<li><a href="#%E8%B5%84%E6%96%99">资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2>
<h3 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h3>
<h4 id="公平锁非公平锁"><a class="markdownIt-Anchor" href="#公平锁非公平锁"></a> 公平锁/非公平锁</h4>
<p>公平锁是指多个线程按照申请锁的顺序来获取锁。</p>
<p>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。</p>
<p>对于 Java <code>ReentrantLock</code>而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。</p>
<p>对于<code>Synchronized</code>而言，也是一种非公平锁。由于其并不像<code>ReentrantLock</code>是通过 AQS 的来实现线程调度，所以并没有任何办法使其变成公平锁。</p>
<h4 id="可重入锁"><a class="markdownIt-Anchor" href="#可重入锁"></a> 可重入锁</h4>
<p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。</p>
<p>说的有点抽象，下面会有一个代码的示例。对于 Java <code>ReentrantLock</code>而言, 他的名字就可以看出是一个可重入锁，其名字是<code>Re entrant Lock</code>重新进入锁。对于<code>Synchronized</code>而言,也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">setA</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    setB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">setB</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，setB 可能不会被当前线程执行，可能造成死锁。</p>
<h4 id="独享锁共享锁"><a class="markdownIt-Anchor" href="#独享锁共享锁"></a> 独享锁/共享锁</h4>
<p>独享锁是指该锁一次只能被一个线程所持有。</p>
<p>共享锁是指该锁可被多个线程所持有。</p>
<p>对于 Java <code>ReentrantLock</code>而言，其是独享锁。但是对于 Lock 的另一个实现类<code>ReadWriteLock</code>，其读锁是共享锁，其写锁是独享锁。读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。独享锁与共享锁也是通过 AQS 来实现的，通过实现不同的方法，来实现独享或者共享。对于<code>Synchronized</code>而言，当然是独享锁。</p>
<h4 id="互斥锁读写锁"><a class="markdownIt-Anchor" href="#互斥锁读写锁"></a> 互斥锁/读写锁</h4>
<p>上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。互斥锁在 Java 中的具体实现就是<code>ReentrantLock</code><br>
读写锁在 Java 中的具体实现就是<code>ReadWriteLock</code></p>
<h4 id="乐观锁悲观锁"><a class="markdownIt-Anchor" href="#乐观锁悲观锁"></a> 乐观锁/悲观锁</h4>
<p>乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。</p>
<p>从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。悲观锁在 Java 中的使用，就是利用各种锁。乐观锁在 Java 中的使用，是无锁编程，常常采用的是 CAS 算法，典型的例子就是原子类，通过 CAS 自旋实现原子操作的更新。</p>
<h4 id="分段锁"><a class="markdownIt-Anchor" href="#分段锁"></a> 分段锁</h4>
<p>分段锁其实是一种锁的设计，并不是具体的一种锁，对于<code>ConcurrentHashMap</code>而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。我们以<code>ConcurrentHashMap</code>来说一下分段锁的含义以及设计思想，<code>ConcurrentHashMap</code>中的分段锁称为 Segment，它即类似于 HashMap（JDK7 与 JDK8 中 HashMap 的实现）的结构，即内部拥有一个 Entry 数组，数组中的每个元素既是一个链表；同时又是一个 ReentrantLock（Segment 继承了 ReentrantLock)。当需要 put 元素的时候，并不是对整个 hashmap 进行加锁，而是先通过 hashcode 来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程 put 的时候，只要不是放在一个分段中，就实现了真正的并行的插入。但是，在统计 size 的时候，可就是获取 hashmap 全局信息的时候，就需要获取所有的分段锁才能统计。分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</p>
<h4 id="偏向锁轻量级锁重量级锁"><a class="markdownIt-Anchor" href="#偏向锁轻量级锁重量级锁"></a> 偏向锁/轻量级锁/重量级锁</h4>
<p>这三种锁是指锁的状态，并且是针对<code>Synchronized</code>。在 Java 5 通过引入锁升级的机制来实现高效<code>Synchronized</code>。</p>
<p>这三种锁的状态是通过对象监视器在对象头中的字段来表明的。</p>
<p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</p>
<p>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</p>
<p>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</p>
<h4 id="自旋锁"><a class="markdownIt-Anchor" href="#自旋锁"></a> 自旋锁</h4>
<p>在 Java 中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗 CPU。</p>
<h3 id="为什么用-lock-readwritelock"><a class="markdownIt-Anchor" href="#为什么用-lock-readwritelock"></a> 为什么用 Lock、ReadWriteLock</h3>
<ul>
<li>
<p>synchronized 的缺陷</p>
<ul>
<li>被 synchronized 修饰的方法或代码块，只能被一个线程访问。如果这个线程被阻塞，其他线程也只能等待。</li>
<li>synchronized 不能响应中断。</li>
<li>synchronized 没有超时机制。</li>
<li>synchronized 只能是非公平锁。</li>
</ul>
</li>
<li>
<p>Lock、ReadWriteLock 相较于 synchronized，解决了以上的缺陷：</p>
<ul>
<li>Lock 可以手动释放锁（synchronized 获取锁和释放锁都是自动的），以避免死锁。</li>
<li>Lock 可以响应中断</li>
<li>Lock 可以设置超时时间，避免一致等待</li>
<li>Lock 可以选择公平锁或非公平锁两种模式</li>
<li>ReadWriteLock 将读写锁分离，从而使读写操作分开，有效提高并发性。</li>
</ul>
</li>
</ul>
<h2 id="lock-和-reentrantlock"><a class="markdownIt-Anchor" href="#lock-和-reentrantlock"></a> Lock 和 ReentrantLock</h2>
<h3 id="要点"><a class="markdownIt-Anchor" href="#要点"></a> 要点</h3>
<p>如果采用 Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用 Lock 必须在 try catch 块中进行，并且将释放锁的操作放在 finally 块中进行，以保证锁一定被被释放，防止死锁的发生。</p>
<p><code>lock()</code> 方法的作用是获取锁。如果锁已被其他线程获取，则进行等待。</p>
<p><code>tryLock()</code> 方法的作用是尝试获取锁，如果成功，则返回 true；如果失败（即锁已被其他线程获取），则返回 false。也就是说，这个方法无论如何都会立即返回，获取不到锁时不会一直等待。</p>
<p><code>tryLock(long time, TimeUnit unit)</code> 方法和 <code>tryLock()</code> 方法是类似的，区别仅在于这个方法在获取不到锁时会等待一定的时间，在时间期限之内如果还获取不到锁，就返回 false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回 true。</p>
<p><code>lockInterruptibly()</code> 方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过 <code>lock.lockInterruptibly()</code> 想获取某个锁时，假若此时线程 A 获取到了锁，而线程 B 只有在等待，那么对线程 B 调用 <code>threadB.interrupt()</code> 方法能够中断线程 B 的等待过程。由于 <code>lockInterruptibly()</code> 的声明中抛出了异常，所以 <code>lock.lockInterruptibly()</code> 必须放在 try 块中或者在调用 <code>lockInterruptibly()</code> 的方法外声明抛出 <code>InterruptedException</code>。</p>
<blockquote>
<p>注意：当一个线程获取了锁之后，是不会被 interrupt() 方法中断的。因为本身在前面的文章中讲过单独调用 interrupt() 方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。因此当通过 lockInterruptibly() 方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。</p>
</blockquote>
<p><code>unlock()</code> 方法的作用是释放锁。</p>
<p>ReentrantLock 是唯一实现了 Lock 接口的类。</p>
<p>ReentrantLock 字面意为可重入锁。</p>
<h3 id="源码"><a class="markdownIt-Anchor" href="#源码"></a> 源码</h3>
<h4 id="lock-接口定义"><a class="markdownIt-Anchor" href="#lock-接口定义"></a> Lock 接口定义</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="reentrantlock-属性和方法"><a class="markdownIt-Anchor" href="#reentrantlock-属性和方法"></a> ReentrantLock 属性和方法</h4>
<p>ReentrantLock 的核心方法当然是 Lock 中的方法（具体实现完全基于 <code>Sync</code> 类中提供的方法）。</p>
<p>此外，ReentrantLock 有两个构造方法，功能参考下面源码片段中的注释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步机制完全依赖于此</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"><span class="comment">// 默认初始化 sync 的实例为非公平锁（NonfairSync）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 根据 boolean 值选择初始化 sync 的实例为公平的锁（FairSync）或不公平锁（NonfairSync）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="sync"><a class="markdownIt-Anchor" href="#sync"></a> Sync</h4>
<ul>
<li><code>Sync</code> 类是 <code>ReentrantLock</code> 的内部类，也是一个抽象类。</li>
<li><code>ReentrantLock</code> 的同步机制几乎完全依赖于<code>Sync</code>。使用 AQS 状态来表示锁的保留数（详细介绍参见 <a href="#aqs">AQS</a>）。</li>
<li><code>Sync</code> 是一个抽象类，有两个子类：
<ul>
<li><code>FairSync</code> - 公平锁版本。</li>
<li><code>NonfairSync</code> - 非公平锁版本。</li>
</ul>
</li>
</ul>
<p align="center">
  <img src="https://raw.githubusercontent.com/dunwu/images/master/images/java/concurrent/ReentrantLock-diagram.png">
</p>
<h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLockDemo demo = <span class="keyword">new</span> ReentrantLockDemo();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; demo.insert(Thread.currentThread())).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; demo.insert(Thread.currentThread())).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(thread.getName() + <span class="string">"得到了锁"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                arrayList.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(thread.getName() + <span class="string">"释放了锁"</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>👉 <a href="https://github.com/dunwu/JavaCore/tree/master/codes/concurrent/src/main/java/io/github/dunwu/javase/concurrent/lock" target="_blank" rel="noopener">更多示例</a></p>
<h2 id="readwritelock-和-reentrantreadwritelock"><a class="markdownIt-Anchor" href="#readwritelock-和-reentrantreadwritelock"></a> ReadWriteLock 和 ReentrantReadWriteLock</h2>
<h3 id="要点-2"><a class="markdownIt-Anchor" href="#要点-2"></a> 要点</h3>
<p>对于特定的资源，ReadWriteLock 允许多个线程同时对其执行读操作，但是只允许一个线程对其执行写操作。</p>
<p>ReadWriteLock 维护一对相关的锁。一个是读锁；一个是写锁。将读写锁分开，有利于提高并发效率。</p>
<p>ReentrantReadWriteLock 实现了 ReadWriteLock 接口，所以它是一个读写锁。</p>
<p>“读-读”线程之间不存在互斥关系。</p>
<p>“读-写”线程、“写-写”线程之间存在互斥关系。</p>
<p align="center">
  <img src="https://raw.githubusercontent.com/dunwu/images/master/images/java/concurrent/ReadWriteLock.jpg">
</p>
<h3 id="源码-2"><a class="markdownIt-Anchor" href="#源码-2"></a> 源码</h3>
<h4 id="readwritelock-接口定义"><a class="markdownIt-Anchor" href="#readwritelock-接口定义"></a> ReadWriteLock 接口定义</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回用于读操作的锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回用于写操作的锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2"><a class="markdownIt-Anchor" href="#示例-2"></a> 示例</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantReadWriteLockDemo demo = <span class="keyword">new</span> ReentrantReadWriteLockDemo();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; demo.get(Thread.currentThread())).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; demo.get(Thread.currentThread())).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (System.currentTimeMillis() - start &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(thread.getName() + <span class="string">"正在进行读操作"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(thread.getName() + <span class="string">"读操作完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="aqs"><a class="markdownIt-Anchor" href="#aqs"></a> AQS</h2>
<blockquote>
<p>AQS 作为构建锁或者其他同步组件的基础框架，有必要好好了解一下其原理。</p>
</blockquote>
<h3 id="要点-3"><a class="markdownIt-Anchor" href="#要点-3"></a> 要点</h3>
<p>作用：AQS，AbstractQueuedSynchronizer，即队列同步器。它是构建锁或者其他同步组件的基础框架（如 ReentrantLock、ReentrantReadWriteLock、Semaphore 等）。</p>
<p>场景：在 LOCK 包中的相关锁(常用的有 ReentrantLock、 ReadWriteLock)都是基于 AQS 来构建。然而这些锁都没有直接来继承 AQS，而是定义了一个 Sync 类去继承 AQS。那么为什么要这样呢?because:锁面向的是使用用户，而同步器面向的则是线程控制，那么在锁的实现中聚合同步器而不是直接继承 AQS 就可以很好的隔离二者所关注的事情。</p>
<p>原理：AQS 在内部定义了一个 int 变量 state，用来表示同步状态。AQS 通过一个双向的 FIFO 同步队列来完成同步状态的管理，当有线程获取锁失败后，就被添加到队列末尾。</p>
<h3 id="源码-3"><a class="markdownIt-Anchor" href="#源码-3"></a> 源码</h3>
<p>AbstractQueuedSynchronizer 继承自 AbstractOwnableSynchronize。</p>
<h4 id="同步队列"><a class="markdownIt-Anchor" href="#同步队列"></a> 同步队列</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 等待队列的队头，懒加载。只能通过 setHead 方法修改。 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">    <span class="comment">/** 等待队列的队尾，懒加载。只能通过 enq 方法添加新的等待节点。*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">    <span class="comment">/** 同步状态 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AQS 维护了一个 Node 类型双链表，通过 head 和 tail 指针进行访问。</p>
<p align="center">
  <img src="http://www.liuhaihua.cn/wp-content/uploads/2018/05/7zei6fI.png">
</p>
<h5 id="node"><a class="markdownIt-Anchor" href="#node"></a> Node</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 该等待同步的节点处于共享模式 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">/** 该等待同步的节点处于独占模式 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 等待状态,这个和 state 是不一样的:有 1,0,-1,-2,-3 五个值 */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 前驱节点 */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">/** 后继节点 */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">/** 等待锁的线程 */</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很显然，Node 是一个双链表结构。</p>
<p>waitStatus 5 个状态值的含义：</p>
<ol>
<li>CANCELLED（1） - 该节点的线程可能由于超时或被中断而处于被取消(作废)状态，一旦处于这个状态，节点状态将一直处于 CANCELLED(作废)，因此应该从队列中移除.</li>
<li>SIGNAL（-1） - 当前节点为 SIGNAL 时，后继节点会被挂起，因此在当前节点释放锁或被取消之后必须被唤醒(unparking)其后继结点.</li>
<li>CONDITION（-2） - 该节点的线程处于等待条件状态，不会被当作是同步队列上的节点,直到被唤醒(signal)，设置其值为 0,重新进入阻塞状态。</li>
<li>PROPAGATE（-3） - 下一个 acquireShared 应无条件传播。</li>
<li>0 - 非以上状态。</li>
</ol>
<h4 id="获取独占锁"><a class="markdownIt-Anchor" href="#获取独占锁"></a> 获取独占锁</h4>
<h5 id="acquire"><a class="markdownIt-Anchor" href="#acquire"></a> acquire</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先调用 tryAcquire 查看同步状态。</span></span><br><span class="line"><span class="comment"> * 如果成功获取同步状态，则结束方法，直接返回；</span></span><br><span class="line"><span class="comment"> * 反之，则先调用 addWaiter，再调用 acquireQueued。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="addwaiter"><a class="markdownIt-Anchor" href="#addwaiter"></a> addWaiter</h5>
<p><code>addWaiter</code> 方法的作用是将当前线程插入等待同步队列的队尾。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 将当前线程构建成 Node 类型</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 2. 判断尾指针是否为 null</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.2 将当前节点插入队列尾部</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.1. 尾指针为 null，说明当前节点是第一个加入队列的节点</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="enq"><a class="markdownIt-Anchor" href="#enq"></a> enq</h5>
<p><code>enq</code> 方法的作用是通过自旋（死循环），不断尝试利用 CAS 操作将节点插入队列尾部，直到成功为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置死循环，是为了不断尝试 CAS 操作，直到成功为止</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 1. 构造头结点（必须初始化，需要领会双链表的精髓）</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 通过 CAS 操作将节点插入队列尾部</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="acquirequeued"><a class="markdownIt-Anchor" href="#acquirequeued"></a> acquireQueued</h5>
<p><code>acquireQueued</code> 方法的作用是通过自旋（死循环），不断尝试为等待队列中线程获取独占锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 1. 获得当前节点的上一个节点</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">// 2. 当前节点能否获取独占式锁</span></span><br><span class="line">                <span class="comment">// 2.1 如果当前节点是队列中第一个节点，并且成功获取同步状态，即可以获得独占式锁</span></span><br><span class="line">                <span class="comment">// 说明：当前节点的上一个节点是头指针，即意味着当前节点是队列中第一个节点。</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 2.2 获取锁失败，线程进入等待状态等待获取独占式锁</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>acquireQueued Before</p>
<p align="center">
  <img src="https://raw.githubusercontent.com/dunwu/images/master/images/java/concurrent/aqs-acquireQueued-before.png">
</p>
<p><code>setHead</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将当前节点通过 setHead 方法设置为队列的头结点，然后将之前的头结点的 next 域设置为 null，并且 pre 域也为 null，即与队列断开，无任何引用方便 GC 时能够将内存进行回收。</p>
<p align="center">
  <img src="https://raw.githubusercontent.com/dunwu/images/master/images/java/concurrent/aqs-acquireQueued-after.png">
</p>
<h5 id="shouldparkafterfailedacquire"><a class="markdownIt-Anchor" href="#shouldparkafterfailedacquire"></a> shouldParkAfterFailedAcquire</h5>
<p><code>shouldParkAfterFailedAcquire</code> 方法的作用是使用 <code>compareAndSetWaitStatus(pred, ws, Node.SIGNAL)</code> 将节点状态由 INITIAL 设置成 SIGNAL，表示当前线程阻塞。</p>
<p>当 compareAndSetWaitStatus 设置失败，则说明 shouldParkAfterFailedAcquire 方法返回 false，重新进入外部方法 acquireQueued。由于 acquireQueued 方法中是死循环，会再一次执行 shouldParkAfterFailedAcquire，直至 compareAndSetWaitStatus 设置节点状态位为 SIGNAL。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="parkandcheckinterrupt"><a class="markdownIt-Anchor" href="#parkandcheckinterrupt"></a> parkAndCheckInterrupt</h5>
<p><code>parkAndCheckInterrupt</code> 方法的作用是调用 <code>LookSupport.park</code> 方法，该方法是用来阻塞当前线程的。</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function"><span class="keyword">return</span> Thread.<span class="title">interrupted</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="acquire-流程"><a class="markdownIt-Anchor" href="#acquire-流程"></a> acquire 流程</h5>
<p>综上所述，就是 acquire 的完整流程。可以以一幅图来说明：</p>
<p align="center">
  <img src="https://raw.githubusercontent.com/dunwu/images/master/images/java/concurrent/aqs-acquire-flow.png">
</p>
<h4 id="释放独占锁"><a class="markdownIt-Anchor" href="#释放独占锁"></a> 释放独占锁</h4>
<h5 id="release"><a class="markdownIt-Anchor" href="#release"></a> release</h5>
<p>release 方法以独占模式发布。如果 tryRelease 返回 true，则通过解锁一个或多个线程来实现。这个方法可以用来实现 Lock.unlock 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断同步状态释放是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="unparksuccessor"><a class="markdownIt-Anchor" href="#unparksuccessor"></a> unparkSuccessor</h5>
<p>unparkSuccessor 方法作用是唤醒 node 的下一个节点。</p>
<p>头指针的后继节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果状态为负值（即可能需要信号），请尝试清除信号。</span></span><br><span class="line"><span class="comment">     * 如果失败或状态由于等待线程而改变也是正常的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放后继节点的线程。</span></span><br><span class="line"><span class="comment">     * 如果状态为 CANCELLED 放或节点明显为空，</span></span><br><span class="line"><span class="comment">     * 则从尾部向后遍历以找到状态不是 CANCELLED 的后继节点。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后继节点不为 null 时唤醒该线程</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h5>
<ul>
<li>线程获取锁失败，线程被封装成 Node 进行入队操作，核心方法在于 addWaiter()和 enq()，同时 enq()完成对同步队列的头结点初始化工作以及 CAS 操作失败的重试 ;</li>
<li>线程获取锁是一个自旋的过程，当且仅当 当前节点的前驱节点是头结点并且成功获得同步状态时，节点出队即该节点引用的线程获得锁，否则，当不满足条件时就会调用 LookSupport.park()方法使得线程阻塞 ；</li>
<li>释放锁的时候会唤醒后继节点；</li>
</ul>
<h4 id="获取可中断的独占锁"><a class="markdownIt-Anchor" href="#获取可中断的独占锁"></a> 获取可中断的独占锁</h4>
<h5 id="acquireinterruptibly"><a class="markdownIt-Anchor" href="#acquireinterruptibly"></a> acquireInterruptibly</h5>
<p>Lock 能响应中断，这是相较于 synchronized 的一个显著优点。</p>
<p>那么 Lock 响应中断的特性是如何实现的？答案就在 acquireInterruptibly 方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        <span class="comment">// 线程获取锁失败</span></span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="doacquireinterruptibly"><a class="markdownIt-Anchor" href="#doacquireinterruptibly"></a> doAcquireInterruptibly</h5>
<p>获取同步状态失败后就会调用 doAcquireInterruptibly 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="comment">// 将节点插入到同步队列中</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 获取锁出队</span></span><br><span class="line">			<span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">				<span class="comment">// 线程中断抛异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与 acquire 方法逻辑几乎一致，唯一的区别是当 parkAndCheckInterrupt 返回 true 时（即线程阻塞时该线程被中断），代码抛出被中断异常。</p>
<h4 id="获取超时等待式的独占锁"><a class="markdownIt-Anchor" href="#获取超时等待式的独占锁"></a> 获取超时等待式的独占锁</h4>
<h5 id="tryacquirenanos"><a class="markdownIt-Anchor" href="#tryacquirenanos"></a> tryAcquireNanos</h5>
<p>通过调用 lock.tryLock(timeout,TimeUnit) 方式达到超时等待获取锁的效果，该方法会在三种情况下才会返回：</p>
<ol>
<li>在超时时间内，当前线程成功获取了锁；</li>
<li>当前线程在超时时间内被中断；</li>
<li>超时时间结束，仍未获得锁返回 false。</li>
</ol>
<p>我们仍然通过采取阅读源码的方式来学习底层具体是怎么实现的，该方法会调用 AQS 的方法 tryAcquireNanos</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">		<span class="comment">// 实现超时等待的效果</span></span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="doacquirenanos"><a class="markdownIt-Anchor" href="#doacquirenanos"></a> doAcquireNanos</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">// 1. 根据超时时间和当前时间计算出截止时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">			<span class="comment">// 2. 当前线程获得锁出队列</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 3.1 重新计算超时时间</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="comment">// 3.2 超时返回 false</span></span><br><span class="line">			<span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			<span class="comment">// 3.3 线程阻塞等待</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="comment">// 3.4 线程被中断抛出被中断异常</span></span><br><span class="line">			<span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p align="center">
  <img src="https://raw.githubusercontent.com/dunwu/images/master/images/java/concurrent/aqs-doAcquireNanos-flow.png">
</p>
<h4 id="获取共享锁"><a class="markdownIt-Anchor" href="#获取共享锁"></a> 获取共享锁</h4>
<h5 id="acquireshared"><a class="markdownIt-Anchor" href="#acquireshared"></a> acquireShared</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尝试获取共享锁失败，调用 doAcquireShared</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">// 当该节点的前驱节点是头结点且成功获取同步状态</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码和 acquireQueued 的代码逻辑十分相似，区别仅在于自旋的条件以及节点出队的操作有所不同。</p>
<h4 id="释放共享锁"><a class="markdownIt-Anchor" href="#释放共享锁"></a> 释放共享锁</h4>
<h5 id="releaseshared"><a class="markdownIt-Anchor" href="#releaseshared"></a> releaseShared</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="doreleaseshared"><a class="markdownIt-Anchor" href="#doreleaseshared"></a> doReleaseShared</h5>
<p>当成功释放同步状态之后即 tryReleaseShared 会继续执行 doReleaseShared 方法</p>
<p>发送后继信号并确保传播。 （注意：对于独占模式，如果需要信号，释放就相当于调用头的 unparkSuccessor。）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="comment">// 如果 CAS 失败，继续自旋</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果头指针变化，break</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="获取可中断的共享锁"><a class="markdownIt-Anchor" href="#获取可中断的共享锁"></a> 获取可中断的共享锁</h4>
<p>acquireSharedInterruptibly 方法与 acquireInterruptibly 几乎一致，不再赘述。</p>
<h4 id="获取超时等待式的共享锁"><a class="markdownIt-Anchor" href="#获取超时等待式的共享锁"></a> 获取超时等待式的共享锁</h4>
<p>tryAcquireSharedNanos 方法与 tryAcquireNanos 几乎一致，不再赘述。</p>
<h2 id="资料"><a class="markdownIt-Anchor" href="#资料"></a> 资料</h2>
<ul>
<li><a href="https://item.jd.com/10922250.html" target="_blank" rel="noopener">Java 并发编程实战</a></li>
<li><a href="https://item.jd.com/11740734.html" target="_blank" rel="noopener">Java 并发编程的艺术</a></li>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3923167.html" target="_blank" rel="noopener">http://www.cnblogs.com/dolphin0520/p/3923167.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/27134110" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27134110</a></li>
<li><a href="https://t.hao0.me/java/2016/04/01/aqs.html" target="_blank" rel="noopener">https://t.hao0.me/java/2016/04/01/aqs.html</a></li>
<li><a href="http://ju.outofmemory.cn/entry/353762" target="_blank" rel="noopener">http://ju.outofmemory.cn/entry/353762</a></li>
<li><a href="https://blog.csdn.net/u012403290/article/details/64910926?locationNum=11&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/u012403290/article/details/64910926?locationNum=11&amp;fps=1</a></li>
<li><a href="https://www.cnblogs.com/qifengshi/p/6831055.html" target="_blank" rel="noopener">https://www.cnblogs.com/qifengshi/p/6831055.html</a></li>
</ul>

      
    </div>

    
      


    

    
    
    

    

    
      
    
    

    
      <div>
        




  



<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Zhang Peng</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    
    <a href="https://dunwu.github.io/2018/05/15/programming/java/javacore/concurrent/锁/" title="锁">https://dunwu.github.io/2018/05/15/programming/java/javacore/concurrent/锁/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/blog/tags/programming/" rel="tag"># programming</a>
          
            <a href="/blog/tags/java/" rel="tag"># java</a>
          
            <a href="/blog/tags/javacore/" rel="tag"># javacore</a>
          
            <a href="/blog/tags/concurrent/" rel="tag"># concurrent</a>
          
            <a href="/blog/tags/lock/" rel="tag"># lock</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/blog/2018/05/10/programming/java/javacore/concurrent/Java并发面试题集/" rel="next" title="Java 并发面试题总结">
                <i class="fa fa-chevron-left"></i> Java 并发面试题总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blog/2018/05/15/programming/java/javacore/concurrent/并发工具类/" rel="prev" title="并发工具类">
                并发工具类 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/blog/images/avatar.gif" alt="Zhang Peng">
            
              <p class="site-author-name" itemprop="name">Zhang Peng</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/blog/archives/">
                
                    <span class="site-state-item-count">342</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/blog/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">29</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/blog/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">115</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/blog/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/dunwu" title="GitHub &rarr; https://github.com/dunwu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:forbreak@163.com" title="E-Mail &rarr; mailto:forbreak@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          
             <div class="cc-license motion-element" itemprop="license">
              
              
                
              
              
              
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/blog/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
             </div>
          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#锁"><span class="nav-text"> 锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-text"> 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-text"> 概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#公平锁非公平锁"><span class="nav-text"> 公平锁/非公平锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可重入锁"><span class="nav-text"> 可重入锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#独享锁共享锁"><span class="nav-text"> 独享锁/共享锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#互斥锁读写锁"><span class="nav-text"> 互斥锁/读写锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#乐观锁悲观锁"><span class="nav-text"> 乐观锁/悲观锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分段锁"><span class="nav-text"> 分段锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#偏向锁轻量级锁重量级锁"><span class="nav-text"> 偏向锁/轻量级锁/重量级锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自旋锁"><span class="nav-text"> 自旋锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么用-lock-readwritelock"><span class="nav-text"> 为什么用 Lock、ReadWriteLock</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lock-和-reentrantlock"><span class="nav-text"> Lock 和 ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#要点"><span class="nav-text"> 要点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#源码"><span class="nav-text"> 源码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#lock-接口定义"><span class="nav-text"> Lock 接口定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reentrantlock-属性和方法"><span class="nav-text"> ReentrantLock 属性和方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sync"><span class="nav-text"> Sync</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例"><span class="nav-text"> 示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#readwritelock-和-reentrantreadwritelock"><span class="nav-text"> ReadWriteLock 和 ReentrantReadWriteLock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#要点-2"><span class="nav-text"> 要点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#源码-2"><span class="nav-text"> 源码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#readwritelock-接口定义"><span class="nav-text"> ReadWriteLock 接口定义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例-2"><span class="nav-text"> 示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#aqs"><span class="nav-text"> AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#要点-3"><span class="nav-text"> 要点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#源码-3"><span class="nav-text"> 源码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#同步队列"><span class="nav-text"> 同步队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取独占锁"><span class="nav-text"> 获取独占锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#释放独占锁"><span class="nav-text"> 释放独占锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取可中断的独占锁"><span class="nav-text"> 获取可中断的独占锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取超时等待式的独占锁"><span class="nav-text"> 获取超时等待式的独占锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取共享锁"><span class="nav-text"> 获取共享锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#释放共享锁"><span class="nav-text"> 释放共享锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取可中断的共享锁"><span class="nav-text"> 获取可中断的共享锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取超时等待式的共享锁"><span class="nav-text"> 获取超时等待式的共享锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#资料"><span class="nav-text"> 资料</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-paper-plane"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Peng</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">2.1m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">31:21</span>
  
</div>









        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
    
      
    
  
  <script color="107,97,95" opacity="0.5" zindex="-1" count="99" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1.0.0/canvas-nest.min.js"></script>











  



  
  <script src="/blog/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-reading-progress@1/reading_progress.min.js"></script>


  


  <script src="/blog/js/src/utils.js?v=7.0.1"></script>

  <script src="/blog/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/blog/js/src/schemes/muse.js?v=7.0.1"></script>



  
  <script src="/blog/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/blog/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/blog/js/src/bootstrap.js?v=7.0.1"></script>


  
  


  


  




  

  

  

  

  

  

  

  

  

  

  

  
  
  
    
  
  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-bookmark@1/bookmark.min.js"></script>
  <script>
  
    bookmark.scrollToMark('auto', "#更多");
  
  </script>


  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      
        background-color: #eee;
        background-image: linear-gradient(#fcfcfc, #eee);
        border: 1px solid #d5d5d5;
        border-radius: 3px;
      
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      
        right: 4px;
        top: 8px;
      
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1;
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function(i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap');
      $(e).after($wrap);
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
        var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
          return $(e).text();
        }).toArray().join('\n');
        var ta = document.createElement('textarea');
        var yPosition = window.pageYOffset || document.documentElement.scrollTop;
        ta.style.top = yPosition + 'px'; // Prevent page scroll
        ta.style.position = 'absolute';
        ta.style.opacity = '0';
        ta.readOnly = true;
        ta.value = code;
        document.body.appendChild(ta);
        ta.select();
        ta.setSelectionRange(0, code.length);
        ta.readOnly = false;
        var result = document.execCommand('copy');
        
          if (result) $(this).text('复制成功');
          else $(this).text('复制失败');
        
        ta.blur(); // For iOS
        $(this).blur();
      })).on('mouseleave', function(e) {
        var $b = $(this).find('.copy-btn');
        setTimeout(function() {
          $b.text('复制');
        }, 300);
      }).append(e);
    })
  </script>


</body>
</html>
